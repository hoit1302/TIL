# 2장 시스템 구조, 프로그램 실행

## 02 프로그램 실행

### 프로그램의 실행

![image](https://user-images.githubusercontent.com/68107000/111315195-7d02e680-86a5-11eb-9cb6-17f76ed08579.png)

1 파일 시스템에 있는 실행 파일을 실행하면 2 프로세스가 되어(Physical memory에 올라감) 3 마치면 종료

근데 물리적 메모리(physical memory)에 올라가기 전에 각 프로세스마다 0번지부터 있는 가상 메모리(virtual memory)---주소 공간이 먼저 생긴 후 주소 변환을 통해 물리적 메모리에 프로세스가 올라간다.

![image](https://user-images.githubusercontent.com/68107000/111315985-382b7f80-86a6-11eb-9f28-cdff4a3aca64.png)

user mode: mode bit 1

kernel mode: mode bit 0

시스템 콜: cpu 제어권이 운영체제에 넘어가서 운영 체제의 주소 공간에 있는 코드가 실행

### 커널 주소 공간의 내용

![image](https://user-images.githubusercontent.com/68107000/111315775-0aded180-86a6-11eb-943e-c4770fc47007.png)

운영체제의 stack은 특이하다.

사용자 프로그램 A 실행 중 OS를 호출하면 커널 스택은 A의 커널 스택을 쓴다. 즉, 각 프로세스마다 별도로 두고 있다.

### 사용자 프로그램이 사용하는 함수

- **사용자 정의 함수** ㅡ> 프로세스 A의 주소 공간
  - 자신의 프로그램에서 정의한 함수
- **라이브러리 함수** ㅡ> 프로세스 A의 주소 공간
  - 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수
  - 자신의 프로그램의 실행 파일에 포함되어 있다.

위 두 함수의 경우, 내 프로그램 안에서 program counter 값만 바꾸어 다른 위치의 기계어를 실행함.

- **커널 함수** ㅡ> 커널 주소 공간
  - 운영체제 프로그램의 함수
  - 커널 함수의 호출 = 시스템 콜

커널 함수의 경우, 가상 메모리의 주소 공간을 가로질러서 다른 프로그램의 영역으로 완전히 바뀜

interrupt line을 세팅해서 CPU 제어권을 운영 체제에 넘기기 때문!
