# 6장 Process Synchronization

## 04 동기화 문제의 해결 방법: Semaphores

### 04-1 Semaphores

하드웨어 적으로~

Semaphore S // semaphore 변수, 정수값, atomic한 P연산과 V 연산에 의해서만 접근 가능.

공유 data 획득 과정

```c

```

공유 data 반납 과정

```c

```

이로써 하나의 프로세스만 이 공유 data에 접근할 수 있는 mutual exclusion 문제를 풀 수 있음.

### busy wait

```

```

하지만 busy wait (=spin lock)은 효율적이지 못함.

만약 누군가 cs에 들어가 있어서 mutex 값이 0이면 P 연산을 빠져나가지 못한다. 다른 친구가 cs를 빠져나가면서 V연산을 통해 mutex값을 1로 복원시키기 전까지는 while문만 돌리면서 쓸데없이 CPU를 낭비한다. 

### block and wakeup

```
// 일단 -1 !!!
```

앞선 value와는 다르다. 여분의 개수를 세는 것이 아니다.

0 이하의 값은 자원에 여분이 없어서 누군가 잠들어있다는 뜻이고 양수는 자원이 남아돌고 있다는 뜻이다.

### 이렇게 해서 semaphores는 2개의 타입으로 분류할 수 있다.

- **counting** semaphore
  - 도메인이 **0이 이상**인 임의의 정수값
  - 주로 resource counting 에 사용 - 자원의 개수를 셈
- **binary** semaphore (=**mutex**)
  - 0 또는 "1"의 값만 가질 수 있는 semaphore
  - 주로 mutual exclusion (lock/unlock)에 사용

### Q. 그렇다면 어떤 게 더 나아? Busy-wait vs Block/wakeup

A. 일반적으로는 Block/wakeup 방식이 더 좋아. 
Critical section의 길이가 긴 경우 또는 cs의 경합(경쟁)이 높을수록 Block/wakeup 방식이 적당해. 하지만 반대인 경우에는 Block/wakeup 방식의 오버헤드가 Busy-wait 오버헤드보다 더 커질 수 있어.

### Semaphores의 문제점
