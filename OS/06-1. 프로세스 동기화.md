# 6장 Process Synchronization

## 01 Race Condition란?

컴퓨터에서 연산을 할 때는 항상 데이터를 읽어와서 연산하고, 그 결과를 다시 어딘가 저장해두도록 되어있다.

race condition이란 하나의 공유 data에 여럿이 접근하려고 할 때, 즉 연산할 수 있는 주체가 여러 개일 때 발생하는 문제를 말한다.![image](https://user-images.githubusercontent.com/68107000/114296399-35298080-9ae6-11eb-89ce-2e6d02fe4093.png)

Storage-box를 공유하는 E-box가 여럿 있는 경우, race condition의 가능성이 있다.

Storage-box : Execution-box의 관계는 

메모리 : CPU(multiprocessor system), 

Address Space : Process 에서 성립할 수 있다.

## 02 언제 race condition 문제가 발생하느냐?

### 02-0 공통적으로...

Q. 프로세스들 간에는 거의, 일반적으로 주소 공간을 공유하지 않는다. 그렇다면 언제 race condition 문제가 발생할까?

A. 공통적으로 **운영체제에 들어가서 작업을 처리할 때** 발생한다. 운영체제에서 작업을 하면 일종의 **공유 데이터**를 갖게 되기 때문이다.

조금 더 자세히 살펴보겠다.

### 02-1 <u>kernal 수행 중 **interrupt** 발생 시</u>

![image](https://user-images.githubusercontent.com/68107000/114296455-643ff200-9ae6-11eb-9ebe-a279671bba7e.png)

커널(OS) 모드에서 수행 중(running)인데 더 긴급한, 중요한 interrupt가 발생하여 interrupt 처리 루틴이 수행하도록 cpu를 넘길 때이다.

양쪽 다 커널 코드이므로 kernal address space를 공유한다.

위 사진의 경우, count 감소 전에 register에 count 값을 읽어들였기에 감소 연산은 반영되지 않을 것이다.

Q. 어떻게 해결할 수 있을까?

A. count 변수를 건드리기 전에 **interrupt disable** 시켜둔다 (= 변수 건드리는 도중에는 interrupt를 받지 않겠다.) 일반적인 시스템에서는 불과 instruction 한 두개 더 처리하는 동안에 문제가 생길만큼 긴급한 일은 발생하지 않는다.

### 02-2 <u>Process 가 system call을 하여 kernal mode 로 수행 중인데 **context switch**가 일어나는 경우</u>

![image](https://user-images.githubusercontent.com/68107000/114296447-5be7b700-9ae6-11eb-9471-a00f206e3de3.png)

프로세스 A와 B 는 각각의 주소 곤강을 사용하기에 data sharing이 없다. 하지만 system call을 하는 동안에는 kernal address space의 data를 access하게 된다. 즉 데이터를 공유하게 된다. 이 작업 중간에 cpu를 빼앗기게 되면 race condition이 발생한다. 

더 자세히 그림을 설명하자면, 프로세스 A의 할당 시간이 끝나 B에게 넘어가면서 context switch가 발생한다. 현재 문맥을 저장하게 되는데, 이 때 count의 값을 이미 cpu에서 register로 읽어들였다. 이후 프로세스 B에서 count++ 연산을 하지만, 다시 A로 문맥 교환이 일어날 때 B 작업 이전의 count 값이 register에 저장되어 있고 이 값으로 이어서 ++의 연산을 한다. 그러므로 B의 작업은 적용이 되지 않는다. 2번이 아닌 1번만 count 값이 증가한다.

Q. 어떻게 해결할 수 있을까?

A. **커널 모드에서 수행 중일 때는 CPU를 빼앗지 못하도록 한다.**

### 02-3 <u>**Multiprocessor**에서 shared memory 내의 kernal data</u>

![image](https://user-images.githubusercontent.com/68107000/114296461-699d3c80-9ae6-11eb-9aee-6f3d308c13c8.png)

Q. 어떻게 해결할 수 있을까?

해결 방법 1. 한번에하나의 cpu만이 커널에 들어갈 수 있게 한다. 가장 간단한 방법이지만 굉장히 큰 overhead를 발생시킨다.

해결 방법 2. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 **데이터 각각에 대해 lock/unlock**을 한다.

## 03 동기화 문제의 해결 방법: Algorithm

### 03-0 <u>프로그램적 해결법의 충족 조건</u>

가정: 모든 프로세스의 수행 속도는 0보다 크다, 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.

- **Mutual Exclusion(상호 배제)**
  프로세스 Pi가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안 된다.
- **Progress(진행)**
  **아무도 critical section에 있지 않은 상태**에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.
- **Bounded Waiting(유한 대기)**
  프로세스가 cricical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.
  이 말은 starvation은 막아야 한다 란 뜻인데, 여럿이 critical section에 들어가고 싶어서 경합이 일어난 상태에서 설명하는 말이다.

✏**critical section**: 각 프로세스의 code segment 중 공유 데이터를 접근하는 **코드**

### 03-1 최초의 시도

아래의 코드는 프로세스들의 일반적인 구조로, 프로세스들은 수행의 등기화를 위해 몇몇 변수를 공유할 수 있다 ㅡ> synchronization variable

```c
do {
    entry section
    critical section // 앞 뒤로 cs 접근 도중에 끊기지 않도록 조치를 취함.
    exit section
    remainder section
} while (1);
```

### 03-2 Algorithm 1

- Synchronization variable
  - int turn: 
  - initially turn = 0:  => Pi can enter its critical

```c
do {
    while (turn != 0); /* My turn? */
    critical section // 내 차례면 공유 코드 수행
    turn = 1:    /* Now it’s your turn 상대방 차례로 바꿈 */
    remainder section
} while (1);
// 내 차례면 공유 코드 수행
// 상대방 차례로 바꿈
```

**Satisfies mutual exclusion, but not progress**

즉, 과잉보호: 반드시 한번씩 교대로 들어가야만 함(swap-turn)
상대방이 turn을 내 값으로 바꿔줘야만 내가 들어갈 수 있음

Q. 특정 프로세스가 더 빈번히 cs에 들어가야 한다면?

A. 차례를 돌아가며 주는 알고리즘이기에 더 자주 cs에 들어가는 프로세스는 상대방이 cs를 하지 않으면 진행이 되지 않는다.

### 03-3 Algorithm 2

- Synchronization variable
  - boolean flag[2];
    initially flag [모두] = false; //no one is in CS
  - if (flag [i] == true): "Pi ready to enter its critical section"

```c
do {
    flag[i] = true;    /* Pretend I am in */
    while (flag[j]);   /* ts he also in? then wait, 상대방 깃발이 내려가면 */ 
    critical section // 나 수행
    flag [i] = false;   /* I am out now, 나올 때 깃발 내림 */
    remainder section
) while (1);

// 나 수행
// 나올 때 내 깃발 내림(= 나 필요없어)
```

내(i)가 깃발만 들고(while 문 이전까지 수행하고) CPU를 빼앗김

상대방이 CPU를 얻어 상대방(j)도 깃발을 들고 다시 CPU를 빼앗음.

나(i)는 상대방(j)을 확인하는데 깃발이 들려있음

ㅡ> 둘 다 2행까지 수행 후 끊임없이 양보하는 상황이 발생할 수 있다.

**Satisfies mutual exclusion, but not progress requirement.**

### 03-4 <u>Algorithm 3 (Peterson's Algorithm)</u>

1번과 2번의 방법을 합친 알고리즘

```c
do {
    flag [I]= true; /* My intention ts to enter .... - 의사 표현 */
    turn = j; /* Set to his(상대방) turn */
    while (flag [j] && turn == j); /* wait only if ...*/
    critical section // 상대방이 깃발을 들지 않았거나 들었지만 내 turn인 경우 수행됨
    flag [i] = false; // 나 이제 더 안써
    remainder section
} while (1);
```

Meets all three requirementsl solves the critical section problem for two processes.

**but Busy Waiting**! (=spin lock, 계속 CPU와 memory를 쓰면서(자원낭비) wait)

busy waiting은 뒤에서 더 자세히 설명

