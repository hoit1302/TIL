# 6장 Process Synchronization

## 05 동기화의 고전적인 문제

### 05-1 **Bounded-Buffer Problem (Producer-Consumer Problem)**

![image](https://user-images.githubusercontent.com/68107000/115099449-e0b45400-9f70-11eb-8e25-f720d7883db0.png)

- <u>Shared data</u>
  - buffer 자체 및 buffer 조작 변수 (empty, full buffer의 시작 위치)
- <u>Synchronization variables</u>
  - mutual exclusion
    - binary semaphore
    - shared data의 mutual exclusion(lock/unlock)을 위해
  - resource count
    - integer(counting) semaphore
    - 남은 full/empty buffer의 수를 표시하기 위해

**코드**

- Synchronization variables
  - **semaphore** full = 0;
  - **semaphore** empty = n, mutex = 1;

```c
Producer
    
do{ ...
    produce an item in x
    P(empty); // 빈 버퍼를 얻는 과정, 만약 없다면 소바자가 나타나서 빈 버퍼를 만들어줄 때까지 기다림
    P(mutex); // lock
   	...
    add x to buffer
	...
    V(mutex); // unlock
    V(full); // 내용 찬 버퍼 추가
} while (1);
---------------------------------------------------------------
Consumer

do {
    P(full); // 내용이 들어있는 버퍼 획득
    P(mutex); // 공유 data lock
    ...
    remove anitem from buffer to y
    ...
    V(mutex);
    V(empty); // 빈 버퍼 추가, 혹시 생산자가 기다리고 있었다면 깨워서 생산할 수 있도록
    ...
    consume the item in y
    ...
} while (1);
```

요약하자면,

> 생산자 프로세스와 소비자 프로세스가 있는데 공유 버퍼에 동시 접근 시 문제 발생
> 버퍼에 대해 락을 거는 semaphore를 사용하고 생상자 입장에서의 자원인 빈 버퍼와 소비자 입장에서의 자원인 내용이 든 버퍼를 카운팅하기 위해서 카운팅 semaphore 를 사용했다.

### 05-2 Readers-Writers Problem

- 한 process가 db에 write 중일 때 다른 process가 접근하면 안됨
- read는 동시에 여럿이 해도 됨
- solution
  - writer가 db에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 reader들을 다 db에 접근하게 해준다.
  - writer는 대기 중인 reader가 하나도 없을 때 db 접근이 허용된다.
  - 일단 writer가 db 접근 중이면 reader들은 접근이 금지된다.
  - wrtier가 db에서 빠져나가야지만 reader의 접근이 허용된다.
- **<u>Shared data</u>**
  - DB 자체
  - readcount : 현재 db에 접근 중인 reader의 수
- **<u>Synchronization variables</u>**
  - mutex: 공유 변수 readcount를 접근하는 코드(cs)의 mutual exclusion 보장을 위해
  - db: reader와 wirter가 공유 db 자체 를 올바르게 접근하게 하는 역할

```c
// Shared data는
int readcount = 0;
DB 자체;
// Synchronization variables는
semaphore mutex = 1, db = 1;
---------------------------------
Writer

P(db);
...
writing DB is performed
...
V(db);
---------------------------------
Reader

P(mutex);
readcount++;
if (readcount == 1) P(db);/*block writer*/
V(mutex); /* readers follow */
...
reading DB is performed
...
P(mutex);
readcount-;
if (readcount == 0) V(db); /*enable writer*/
V(mutex):
```



### 05-3 Dining-Philosophers Problem

```c
// Synchronization variables는
semaphore chopstick[5];
/* Initially all values are 1 */

Philosopher i
do {
    P(chopstick[i]);
    P(chopstick[(i+1) % 5]);
    ...
    eat();
    ...
    V(chopstick[i]);
    V(chopstick[(i+1) % 5]);
    ...
    think();
    ...
} while (1);
```

- 앞의 solution의 문제점
  - deadlock 가능성이 있다
  - 모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우

* 해결 방안
  * 4 명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다
  * 젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다
  * 비대칭: 짝수(훌수) 철학자는 왼쪽 (오른쪽) 젓가락부터 집도록

```c
enum {thinking, hungry, eating} state[5];
semaphore self[5] = 0;
semaphore mutex = 1;

void test (int i) {
    if (state[(i+4)%5] != eating && state[i] == hungry && state[(i+1)% 5] != eating) {
    	state[i] = eating;
        V(self[i]);
}
void putdown(int i) {
    P(mutex);
    state[i] = thinking;
    test((i+4) % 5);
    test((i+1) % 5);
    V(mutex);
}
void pickup(int i) {
    P(mutex);
    state[i] = hungry;
    test(i);
    V(mutex);
    P(self[i]);
}
    
Philosopher i
do{ 
    pickup(i);
    eat();
    putdown(i);
    think();
} while(1);
```



## 06 동기화 문제의 해결 방법: Monitor

### 06-1 등장 배경: Semaphore의 문제점

- 코딩하기 힘들다
- 정확성(correctness)의 검증, 입증이 어렵다
- 자발적 협력(voluntary cooperation)이 필요하다
- 한번의 실수가 모든 시스템에 치명적인 영향을 준다.

ㅡ> process 동기화 문제를 더 쉽게 해결하기 위해 등장한 monitor

### 06-2 Monitor

공유 data에 동시 접근 시 문제가 발생하는 건데, 이 공유 data를 모니터 안에 정의해주고 접근을 모니터 안의 코드 연산만으로 가능하게 한다.

고급 언어 프로그래밍 차원에서 구현된 것이다.

- 모니터 내에서는 한번의 프로세스만이 활동 가능
- 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요 없음 !!
- 프로세스가 모니터 안에서 기다릴 수 있도록 condition variable을 사용한다.
  ex) condition x, y;
- condition variable은 wait와 signal 연산에 의해서만 접근 할 수 있다.
  - **x.wait();**
    x.wait()를 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke하기 전까지 **suspend**된다.
    자원의 여분이 없을 땐 blocked queue에 가서 줄을 서도록 하는데 즉 잠근다.(blocked)
  - **x.signal();**
    x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다.
    Suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.
    자원의 여분이 있을 땐 수행된다.

semaphore는 원자적으로 수행하도록 하는 것이지만 monitor는 기본적으로 동시 접근을 아예 막는다.

따라서 프로그래머는 동시 접근 문제를 생각할 필요가 없다. 그냥 빈 버퍼가 있는지 확인한 뒤 기다리거나(잠들게 하거나) 수행하면 된다.

**코딩 방법**

```
// 혹시 잠들어 있으면 깨워라(O), semaphore 처럼 condition variable에 반영(X)
내용 들어있는 버퍼 체크
없으면 내용 들어있는 버퍼를 기다리는 큐에 즐서서 잠듦. (그러다 나중에 생산자가 내용이 든 버퍼를 만들어주면 깨어남)
꺼내감
```

**예시 - Dining Philosophers**

