## 소프트웨어 개발 단계(SW Life Cycle)

### 요구사항 분석(Requirement analysis) 

- SW 개발 전에 개발자(SW developer)가 사용자의 정확한 요구사항(입력, 출력, 처리 논리, 처리 환경 등)을 파악한다.
- 사용자와의 대화 및 문서 등을 통해 일의 범위를 파악한다.
- 필요한 개발 내용을 개발자에게 정확하게 전달해야 한다.

### 설계(Design) 

- 개발될 프로그램을 **설계**한다. 즉, SW 해결책을 위한 문제해결과 계획 과정이다.
- 분석 단계보다는 좀더 구체적인 과정으로 프로그램의 흐름(알고리즘 또는 로직), 자료의 내용에 관한 설계이다. 
- 즉, **자료 표현 방식**을 택하고 **알고리즘 기술 언어**를 사용하여 **알고리즘들을 작성**함. (설계 도구 사용 가능)

### 프로그래밍(Programming)

- 설계된 논리를 직접 프로그래밍 언어로 바꾸는 작업이다.
- 즉, 기술한 알고리즘을 C, 파이썬 또는 자바와 같은 **언어를 사용하여 코딩**하는 과정이다.
- 고려사항
  - **적절하고 좋은 프로그래밍 언어**를 선택한다.
  - 어떻게 하면 **빠르고 정확한 프로그램**을 개발할 것인가? 
  - 입력 자료나 프로그램 내의 **자료를 어떻게 구성**할 것인가? - 자료구조
  - 프로그램을 **다른 사람이 쉽게 알아볼 수 있**도록 작성한다. - 가독성(readability)

### 테스트(Test)

- 작성된 프로그램을 **모의 입력 자료**나 **실제 입력 자료**를 이용하여 검증한다. (여러 사례 고려)
- 예측한 결과가 나오는지 **실험적으로** 정확성을 증명하는 과정이다.

### 사용(Use)

- 사용자가 SW 개발자로부터 **프로그램을 인계 받아서 사용**한다.
- 프로그램의 설치 방법, 수행하는 방법, 문제가 발생했을 때 처리 방법을 배우거나 문서로 설명된 자료(document/manual) 인계인수
- 테스트 단계에서 고려하지 못했던 입력 자료나 환경이 발생할 가능성 있다.

### 유지보수(Maintenance)

- 사용자가 프로그램을 사용하는 도중에 발생하는 **오류(bug) 수정**, **새로운 기능의 추가**, 운영체제 변경에 따른 **재개발**, **보안 패치** 등
- SW 개발자는 보통 개발 업체를 떠나는 경우가 많음



## 좋은 소프트웨어(프로그램)란?

- **시스템 관점** 
  - *실행 시간*이 빠르고, 
  - *기억 장소를 적게 사용*하는 프로그램 
- **사용자** **관점** 
  - *사용*이 쉽고, 
  - *유지보수*하기 편하고,
  - *요구사항 변경에 적응*하기 쉬운 프로그램 
- **SW 개발자 관점** 
  - 시스템 관점과 사용자 관점을 *모두 고려*
  - 적절한 자료구조와 이해하기 쉬운 알고리즘 사용
  - 정확성 검증이 쉬운 프로그램



## 컴퓨터 프로그램의 구성

컴퓨터 프로그램 구성에 대한 비유

- 프로그램 = 자료구조 + 알고리즘 (by N. Wirth)
- 프로그램이 문장(statements)이면 자료구조는 명사(nouns), 알고 리즘은 동사(verbs)
- (예) 최대값 탐색 프로그램 = 배열 + 순차탐색



## 자료구조(Data Structures)

컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조

즉, 자료들 사이의 관계를 반영하여 자료를 효율적으로 처리할 수 있도록 컴퓨터에 저장하는 방법. 구체적인 구현까지 포함 가능

### 자료형(data type) 또는 데이터 타입

특정 프로그래밍 언어에서 제공하는 기본적인 자료(또는 원소) 및 연산의 집합

### 추상자료형(ADT: Abstract Data Type) 또는 추상 데이터 타입자료 + 연산

- 자료형을 추상적(수학적)으로 정의한 것이다.
- **자료와 연산이 무엇(what)인가**를 정의한다.
- 자료와 연산을 어떻게(how) **구현할 것인지는 정의하지 않는다** 
- (예) 정수, 전화번호부, 스택, 큐 등



- 자연수 ADT

  ```pseudocode
  Nat_No
  • 자료(또는 원소) : 0에서 시작하여 INT_MAX까지의 순서화된 정수의 부분범위
  • 연산 :
          zero() ::= return 0;
          is_zero(x) ::= if ( x=0 ) return TRUE; else return FALSE;
          add(x, y) ::= if ( (x+y) <= INT_MAX ) return x+y;
          else return INT_MAX
          sub(x, y) ::= if ( x<y ) return 0; else return x-y;
          equal(x, y) ::= if ( x=y ) return TRUE; else return FALSE;
          successor(x) ::= if ( (x+1) <= INT_MAX ) return x+1;
  ```

  

## 알고리즘(Algorithm)

컴퓨터로 문제를 풀기 위한 단계적인 절차

### 알고리즘의 특징

(※ Donald Knuth에 의한 정의임. 1968, 1973)

1. 입력 조건(**input**) : 외부에서 제공 가능(zero or more) 
2. 출력 조건(**output**) : 하나 이상의 출력을 생성해야 함(one or more) 
3. 명확성(**definiteness**) : 각 명령은 모호하지 않아야 함 
4. 유한성(**finiteness**) : 유한 스텝 후 종료해야 함
5.  효과성(**effectiveness**) : 모든 명령어들은 원칙적으로 사람에 의해 종이와 연필만으로도 수행될 수 있도록 단순하고 기본적인 것이어야 함

ㅡ> “좋은 알고리즘” - 효율성(efficiency), 단순성(simplicity) 및 우아함(elegance)

### 알고리즘의 기술 방법 

- **영어나 한국어와 같은 자연어(natural language)** 

  - 인간이 읽기가 쉽다. 

  - 그러나 자연어의 단어들을 정확하게 정의하지 않으면 의미 전달이 모호해질 우려가 있다.

  - (예) 배열에서 최대값 찾기 알고리즘

    ```
    ArrayMax(A,n)
    1. 배열 A의 첫 번째 원소를 변수 tmp에 복사
    2. 배열 A의 다음 원소들을 차례대로 tmp와 비교하여 더 크면 tmp로 복사
    3. 배열 A의 모든 원소와 비교했으면 tmp를 반환
    ```

- **흐름도(flowchart)** 

  - 직관적이고 이해하기 쉽다.
  - 복잡한 알고리즘의 경우, 그림이 상당히 복잡해진다.
  - ![image](https://user-images.githubusercontent.com/68107000/96492307-67b49800-127e-11eb-8e2f-0b726c4c8e05.png)

- **의사 코드(pseudo-code)**

  - 알고리즘의 고수준(high-level) 기술 방법 

  - 자연어와 프로그래밍 개념의 중간 

    - 자연어보다는 더 구조적인 표현 방법 
    - 프로그래밍 언어보다는 덜 구체적인 표현 방법 

  - 알고리즘을 기술할 때 **가장 많이 사용**

  - 알고리즘의 핵심적인 내용에만 집중할 수 있게 함 

    - 프로그램을 구현할 때의 여러 문제들을 감출 수 있다. (구현시 필요한 구체적인 문제들은 나중에 고려한다)

  - ```pseudocode
    Max(A,n)
        currentMax ← A[0];
        for i← (1 to n-1) do	
            if currentMax < A[i] then
                currentMax ← A[i];
        return currentMax;
    ```

- **특정 프로그래밍 언어 (Python, C/C++, Java 등)**

  - 알고리즘에 대한 가장 정확한 기술이 가능 

  - 그러나, 실제 구현시의 많은 구체적인 사항들이 알고리즘의 핵심적인 내용들의 이해를 방해할 수 있음

  - ```C
    #define MAX_ELEMENTS 100
    int score[MAX_ELEMENTS];
    int find_max_score(int n) {
        int i, tmp;
        tmp=score[0];
        for (i=1;i<n;i++) {
    	    if (score[i] > tmp )   tmp = score[i];
        }
        return tmp;
    }
    ```

    

## 알고리즘의 성능분석

- 알고리즘 성능 분석의 주요 기준 
  - 시간 복잡도(**time complexity**) 분석 : 실행 시간 분석
  - 공간 복잡도(**space complexity**) 분석 : 실행시 필요한 기억 공간(메모리) 분석



- 시간 복잡도 분석

  1. **실제 실행 시간**을 측정하는 방법

     - 알고리즘을 구현한 프로그램의 실제 실행 시간을 측정

     - 실제 프로그래밍 언어로 구현하여 다양한 입력 자료에 대해 실행

     - 동일한 하드웨어를 사용, 동일한 프로그래머가 작성

     - 실행 시간 측정 프로그램 예

       ```c
       #include <stdio.h>
       #include <stdlib.h>
       #include <time.h>
       void main() {
           clock_t start, finish;    double duration;
           start = clock(); // clock_t clock(void);
           /* 수행시간을 측정하고 하는 코드... */
           finish = clock(); // 호출되었을 때의 시스템 시각 반환
           duration = (double)(finish ‐ start)/CLOCKS_PER_SEC; //초단위로 보려면 CLOCKS_PER_SEC로 나눔  
           printf("%f 초입니다.\n", duration);
       }
       ```

       

  2. 알고리즘의 **복잡도를 분석**하는 방법
     - 직접 구현하지 않고 **이론적으로 실행 시간을 예측**하는 것
     - 알고리즘이 실행하는 전체 문장 또는 주요 연산의 횟수를 측정
     - 일반적으로 이러한 횟수는 **입력의 크기(즉, 입력 값 또는 개수) n의 함수**
     - 밑에서 자세히.



##  알고리즘의 복잡도 분석

### 시간 복잡도(time complexity) 

- **시간복잡도 함수 T(n)**
  - 알고리즘 수행에 필요한 **연산의 개수**를 입력의 크기 n에 대한 함수로 나타냄
- 산술, 대입, 비교, 이동 등 기본적인 연산 고려
  - 정렬 알고리즘 : 원소 쌍의 비교
  - 탐색 알고리즘 : 키(key)와 원소의 비교
  - 행렬의 곱셈 알고리즘 : 정수 또는 실수의 곱셈 및 덧셈 

### 공간 복잡도(space complexity) 

- **공간복잡도 함수 S(n)**
  - 입력, 중간 결과 및 최종 결과 저장에 필요한 **공간의 크기**를 입력의 크기 n에 대한 함수로 나타냄

### 빅오 표기법(Big-O notation)

빅 오는 **함수의 상한**을 표시한다.

두 개의 함수 f(𝒏)과 g(𝒏)이 주어졌을 때, 모든 𝒏 ≥ 𝒏𝟎에 대하여 |f(𝒏)| ≤ 𝒄 ∗|g(𝒏)|을 만족하는 2개의 상수 𝒄와 𝒏𝟎가 존재하면 f(n)=O(g(𝒏)) ( 또는 f(𝒏)∈O(g(𝒏)) )으로 표기

연산의 횟수를 대략적(점근적, asymptotically)으로 표기한 것

- 동기 : 시간 및 공간 복잡도 함수를 간단히 표현 
  - 차수가 가장 큰 항이 영향을 가장 크게 미치고, 차수가 작은 다른 항들은 상대적으로 무시될 수 있음
  - 차수는 계수(상수)보다 훨씬 영향이 큼

### 빅 오메가 표기법 (Big-Ω notation)

빅 오메가는 **함수의 하한**을 표시한다.

두 개의 함수 f(𝒏)과 g(𝒏)이 주어졌을 때, 모든 𝒏 ≥ 𝒏𝟎에 대하여 |f(𝒏)| ≥ c|g(𝒏)|을 만족하는 2개의 상수 𝒄와 𝒏𝟎가 존재하면 f(𝒏)∈Ω(g(𝒏))이다.

### 빅 세타 표기법 (Big-ϴ notation)

빅 세타는 **함수의 하한**인 동시에 **상한**을 표시한다.

모든 𝒏 ≥ 𝒏𝟎에 대하여, 𝒄𝟏|g(𝒏)| ≤ |f(𝒏)| ≤ 𝒄𝟐|g(𝒏)|을 만족하는 3개의 상수 𝒄𝟏, 𝒄𝟐 와 𝒏𝟎가 존 재하면 f(𝒏)∈ ϴ(g(𝒏))이다.