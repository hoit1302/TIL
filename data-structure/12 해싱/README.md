# 해싱(Hashing)

## 1. 해싱의 개념, ADT

기존의 대부분 탐색 방법들은 키 값을 비교하여 탐색하고자 하는 항목에 접근

### 해싱이란?

키 값에 대한 산술적 연산에 의해 테이블의 주소를 계산하여 항목에 접근

해싱은 물건을 정리해 놓는 것과 유사하다.

물건이 섞여 있는 상태로 두었다가 필요할 때 하나씩 탐색하는 게 아니라 (O(n), O(log n), … ) 각 물건마다 고유한 위치에 물건을 보관하는 것이다. 

탐색 시간 : 이론적으로 O(1)

**해시 테이블(hash table)**

- 키 값의 연산에 의해 직접 접근이 가능한 구조

  

### 추상데이터형 : 사전식 구조(dictionary)

사전식 구조란 탐색, 삽입 및 제거 연산을 효율적으로 수행할 수 있는 자료 구조를 말한다. 맵(map) 또는 테이블(table)이라고도 부른다. 

- 구성 필드
  - **키(key)** : 항목들의 식별기준 – (예) 영어 단어, 주민등록번호, 학번 등
  - **값(value)** : 키와 관련된 값 – (예) 한글 뜻, 의료보험정보, 성명/소속학과/주소/전화번호 등

![image](https://user-images.githubusercontent.com/68107000/100823388-7904dd00-3497-11eb-8ff4-720292474727.png)

- 항목 접근방법

  만약 키 0, 1, … , 999 이라면 배열[1000]에 저장한다. 탐색 키는 배열의 인덱스이고 탐색에 O(1) 의 시간이 걸린다.

  그러나, 실제 탐색 키는 문자열 또는 매우 큰 수(예 : 주민번호-인구)이다.

  이를 해결하기 위해 큰 키 값이나 문자열을 **작은 정수값으로 사상(mapping)** 한다.

  **탐색 키만을 가지고 바로** 항목이 저장되어 있는 **해시 테이블의 위치를 결정**하는 방법을 사용하는 것이다.

  해시 테이블의 다른 항목에는 접근할 필요가 없어지도록 한다.

  ![image](https://user-images.githubusercontent.com/68107000/100824494-96d34180-3499-11eb-9306-930d11003f0c.png)

  ## 2. 해싱의 구조
  
  ![image](https://user-images.githubusercontent.com/68107000/100823999-abfba080-3498-11eb-92de-fde2e7c94e0e.png)

**해싱 (hashing)** : 해시 함수와 해시 테이블을 이용한 키 값의 탐색, 삽입, 제거 기법 해싱의 탐색 구조 

**해시 주소 (hash address)** : 해시 함수에 의해 결정된 탐색 키의 저장주소 (해시 테이블의 인덱스) 

**해시 함수(hash function)** : 탐색 키를 입력 받아 해시 주소 생성

**해시 테이블(hash table)** : 탐색 키로부터 해시 함수에 의해 저장 위치를 직접 계산할 수 있는 테이블 구조(주로 배열, 크기 M) 

- **해시 테이블 ht**
  - M개의 버킷(bucket)으로 구성된 테이블
  - 하나의 버킷에 s개의 슬롯(slot) 가능 – 하나의 슬롯엔 하나의 항목 저장 – 서로 다른 두 키의 해시값이 동일할 경우, 동일한 해시 주소에 s개의 항목을 저장할 수 있음 
- **충돌(collision)** 
  - 서로 다른 두 개의 탐색키 k1과 k2에 대하여 h(k1) = h(k2)인 경우 (k1과 k2는 동의어(synonym) 이라 함) 
- **오버플로우(overflow)** 
  - 충돌이 버킷에 할당된 슬롯 수보다 많이 발생 하는 것 
  - 오버플로우 해결 방법이 반드시 필요

![image](https://user-images.githubusercontent.com/68107000/101057256-334b3000-35cf-11eb-98c8-8daf5804c7fd.png)

이상적인 해싱의 예: 학생 정보를 해싱으로 저장하고 탐색할 때 5자리 학번 중에 앞 2자리가 학과 번호, 뒤 3자리가 각 학과의 학생 번호 가정한다. 같은 학과 학생들만 가정하면 뒤의 3자리만 사용해서 탐색이 가능하다. 학번이 00023이라면 이 학생의 인적 사항은 해시테이블 ht[23]에 저장하면 된다. 만약 해시 테이블이 1,000개의 공간을 가지고 있다면 탐색 시간이 O(1)이 되므로 이상적이다.

하지만 실제로는 해시 테이블의 크기가 제한되므로, 존재 가능한 모든 키에 대 해 저장 공간을 할당할 수 없다.

단적인 예로, 주민등록번호는 13자리이기에 키 공간으로 10^13 (10조개)이 필요하다. 하지만 실제 인구는 5,125만명이다. **일반적으로 탐색 키의 공간에 비해 해시 테이블 크기는 작다.**

해시 함수가 *h(k)= k mod M(해시 테이블 크기)*일 경우 필연적으로 충돌 및 오버플로우가 발생한다.

해시 함수가 *알파벳 문자열 키의 첫 번째 문자*의 순서라고 한다면 충돌 및 오버플로우가 발생한다.

따라서  시간복잡도는 이상 적인 경우의 O(1)보다 좋지 않게 된다.

## 3. 해시 함수

### **좋은 해시 함수의 조건** 

- 계산이 빨라야 함 
- 충돌이 적어야 함 
- 해시 함수 값이 해시 테이블의 주소 영역 내에서 *고르게 분포*되어야 함

### 해시 함수의 종류 (탐색 키가 숫자인 경우)

- **제산(division) 함수**

  - h(k) = k mod M
  - 해시 테이블의 크기 **M은 소수(prime number) 선택** 
  - M 선택은 매우 중요
    - M = 2^x 형태이면, 해시값은 탐색 키의 최하위 x비트에 의해서만 영향을 받는다. 뒷부분 x비트 문자들이 같은 탐색 키는 충돌이 일어난다.
    - M이 짝수이면, 짝수/홀수 탐색 키는 각각 짝수/홀수 버킷으로 매핑이 되므로 안좋다.
    - 보통 M은 소수 사용
    - 좋은 M의 예 
      - x, a : 적당히 작은 정수
      - r : 문자 집합에 대한 기수(radix) 예. ASCII 문자에 대한 기수 r = 2^7 = 128 
      - **M : r^x ± a의 약수가 아닌 소수**

- **접지(폴딩, folding) 함수**

  - 주로 탐색 키가 해시 테이블 크기보다 더 **큰 정수**일 때 사용

  - 해시주소 : 탐색 키를 **여러 부분으로 나누어 모두 더한 값**을 사용

  - 이동 접지(shift folding)과 경계 접지(boundary folding)

  - (예) 해시 주소가 10진수 3자리로 구성된 경우

    ![image](https://user-images.githubusercontent.com/68107000/101065270-49a9b980-35d8-11eb-87f1-e6a3b13237a8.png)

- **중간 제곱(mid square) 함수**

  - 탐색 키를 **제곱**한 다음, **k개의 중간 비트**를 취해서 해시 주소를 생성하는 방법이다.
  - 제곱값의 중간 비트들은 대개 탐색 키의 모든 문자와 관련되므로 **비교적 고르게 분산**된다.

- **비트 추출(bit extraction) 함수**

  - 탐색 키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용
  - 간단하지만 탐색 키의 일부 정보만 사용하므로 해시 주소의 **집중현상(clustering)**이 발생할 수 있다.

- **숫자 분석(digit analysis) 방법**

  - 키 중에서 편중되지 않는 수들을 해시 테이블의 크기에 적합하게 조합하여 사용
  - (예) 학번 : 1712045 – 앞의 2자리는 편중되어 가급적 사용하지 않고 나머지 수를 조합하여 해시 주소로 사용



### 해시 함수의 종류 (탐색 키가 문자열인 경우)

- **‘a’ ~ ‘z’ : 0 ~ 25 값을 할당**하여 해시 주소로 변환

- 문자의 **아스키코드 또는 유니코드 값**을 사용

  - 첫번째 문자의 아스키코드값을 해시 주소로 사용하면 “book”과 “cup”은 구별 가능하나 “cup”과 “car”는 구별이 불가능하다.

- **각 문자의 아스키코드값을 모두 더한 값을 사용**

  -  충돌 방지를 위해 문자열 안의 모든 문자를 골고루 사용
  - “are”, “era” 구별이 불가능하다.
  - 또한 아스키코드 범위가 65 ~122 è 3자리 문자열의 경우 195~366에 집중된다.

- **문자들의 아스키 코드 값 * 위치값**

  - 충돌 방지를 위해 문자열 안의 모든 문자를 골고루 사용

  - 문자열 s가 n개의 문자로 구성, i번째 문자를 u_i라 할 경우 (보통 g는 31 사용)

    ![image](https://user-images.githubusercontent.com/68107000/101064956-eae44000-35d7-11eb-8e3f-79d88105c836.png)

  - 계산량을 줄이는 Horner의 방법

    ![image](https://user-images.githubusercontent.com/68107000/101064909-dbfd8d80-35d7-11eb-9582-28fbd24bb660.png)

## 4. 오버플로우 해결책: 선형 조사법, 체이닝

### 충돌 (Collision)

서로 다른 탐색 키들이 같은 해시 주소를 갖는 현상

이상적 해시 함수를 이용하고 해시 테이블이 충분히 커도 충돌은 필연적으로 발생(생일 역설 참고) 

충돌에 의해 오버플로우가 발생하면 해시 테이블에 해당 항목 저장 불가능

오버플로우를 효과적으로 해결하는 방법 반드시 필요 

> 참고 : 생일 역설(Birthday paradox)
>
> 23명만 있으면, 2명 이상 생일이 같을 확률이 0.5 이상
>
> 테이블 크기가 365, 탐색 키 23개 시, 적재 비율 = 23/365 = 6.3% 이지만, 예상 외로 충돌이 일어날 확률은 0.5 이상
>
> 모든 사람(n명)들의 생일이 다를 확률![image](https://user-images.githubusercontent.com/68107000/101116847-3a069100-3629-11eb-8d48-741da0ac20e7.png)
>
>  ![image](https://user-images.githubusercontent.com/68107000/101116983-720dd400-3629-11eb-8527-576d8423982d.png)
>
> n명중 둘 이상이 생일이 같을 확률 = 1 − ![image](https://user-images.githubusercontent.com/68107000/101116847-3a069100-3629-11eb-8d48-741da0ac20e7.png)

### 1안 개방주소법(open addressing)

**1-1 선형 조사법(linear probing)**

조사하는 위치 : **(h(k) + i) mod M, i = 0, 1, 2, …**

충돌이 ht[k]에서 발생했다면, ht[k]+1이 비어 있는지 조사한다. 

만약 비어있지 않다면 ht[k]+2 조사하고 비어있는 공간이 나올 때까지 계속 조사한다.

테이블의 마지막에 도달하게 되면 다시 테이블의 처음부터 조사한다.

조사를 시작했던 곳으로 다시 되돌아오게 되면 테이블이 가득 찬 것이다.

이 방식은 **군집화(clustering)** 문제가 발생한다.

군집화란 한 번 충돌이 시작되면 그 위치 근처에 항목들이 집중 되는 현상이다. 빈 공간 탐색 시간이 오래 걸린다.

예1: h(k) = k mod 7 (슬롯이 1개인 경우), 키: 8 1 9 6 13

![image](https://user-images.githubusercontent.com/68107000/101118276-14c75200-362c-11eb-81aa-e6a32c15278d.png)

예2 f(key) = ∑ key_i % 13, key: “do”(3), “for”(2), “if”(12), “case”(9), “else”(9), “return”(9), “function”(12)

![image](https://user-images.githubusercontent.com/68107000/101118489-7be50680-362c-11eb-8215-b17ab4a566ab.png)![image](https://user-images.githubusercontent.com/68107000/101118358-3cb6b580-362c-11eb-8aef-45623d86be8f.png)



**1-2 이차 조사법(quadratic probing)**

조사하는 위치 : **(h(k) + i^2) mod M, for i = 0, 1, … , M-1** 

예를 들면, H(k), h(k)+1, h(k)+4, h(k)+9, … 

선형 조사법에서의 문제점인 **군집화(clustering)를 크게 완화**시킬 수 있다.

**2차 집중 문제**를 일으킬 수 있으나 1차 집중보다는 덜 심각하다. 

2차 집중 이유는 동일한 위치로 사상되는 여러 탐색 키들이 같은 순서에 의하여 빈 버킷을 조사하기 때문이다.



**1-3 이중 해싱법(double hashing)**

충돌 발생시 원 해시함수 h(k)와 다른 별개의 해시함수 h’(k)를 추가로 사용하는 방법이다.

**h(k) = k mod M, h’(k) = C - (k mod C)**, C는 해시테이블 크기 M 보다 약간 작은 소수

충돌 발생시 조사되는 위치 : h(k)+ i*h’(k) mod M, (i = 0, 1, 2, … )

이중 해싱에서는 집중 현상이 드물다.

예1 

크기가 7인 해시 테이블

첫 번째 해시 함수 h(k) = k mod 7

오버플로우 발생시 제 2의 해시 함수 h’(k) = 5 - (k mod 5) 

입력 (8, 1, 9, 6, 13)

![image](https://user-images.githubusercontent.com/68107000/101118583-b9e22a80-362c-11eb-9123-e39eb78f3ea5.png)

![image](https://user-images.githubusercontent.com/68107000/101118521-9323f400-362c-11eb-88a1-31d8df1dc022.png)

**1-4 재해싱(rehashing)**

해시 테이블이 점점 차게 되면 집중 현상으로 연산 시간이 많이 걸림 → 재해싱 필요

원래 해시 테이블의 **적재 비율(load factor, m/M)이 어느 정도 커**지면 

**새로운 해시 함수**와 **2배 이상 소수 크기의 새로운 해시 테이블**을 생성하고

원래 해시 테이블의 **모든 탐색 키들을** 새로운 해시 테이블로 **재해싱**

![파일_000 (1)](https://user-images.githubusercontent.com/68107000/101118965-99ff3680-362d-11eb-9d97-bca2bd5abfde.png)

**재해싱 분석** 

(M은 해시 테이블 크기, m은 키의 개수)

시간복잡도 : O(n) 시간, (n은 # of keys) == O(m)

새 해시 테이블 크기 : 2M 보다 조금 큰 소수

**재해싱이 필요한 경우**

적재 비율 λ가 임계값(예 : 0.5 또는 0.7)을 넘으면 성능이 저하된다. 따라서 임계값을 설정하여 초과되면 재해싱이 필요하다.

λ가 작더라도 탐색 키를 삽입하지 못하는 상황이 발생하는 경우, 재해싱이 필요하다.

재해싱은 오버플로우 해결기법에도 사용이 가능하다.

### 2안 체이닝(chaining)



## 5. 해싱의 성능분석

