# 정렬

정렬은 물건을 크기 순으로 오름차순이나 내림차순으로 나열하는 것 

정렬은 컴퓨터공학을 포함한 모든 과학기술 분야에서 가장 기본적이고 중요한 알고리즘 중 하나 

정렬은 자료 탐색에 있어서 필수적 (예) : 만약 영어사전에서 단어들이 알파벳 순으로 정렬되어 있지 않다면?

### 정렬의 대상

- 일반적으로 정렬하는 대상은 **레코드**(record)의 모임 
- 레코드는 **필드**(field)라는 작은 단위로 구성 
- **키(key) 필드**로 레코드와 레코드를 구별한다.
  - Primary key
  - Secondary key

![image](https://user-images.githubusercontent.com/68107000/99208698-99306d00-2804-11eb-81f9-39230e106c87.png)

### 정렬 알고리즘

- **모든 경우에 최적인 정렬 알고리즘은 없다. 각 응용 분야에 적합한 정렬 방법 사용해야 한다.** 
  - 레코드 수의 많고 적음 
  - 레코드 크기의 크고 작음 
  - Key의 특성(문자, 정수, 실수 등) 
  - 메모리 내부/외부 정렬 

- **정렬 알고리즘의 평가 기준**
  - 비교 횟수의 많고 적음 
  - 이동 횟수의 많고 적음

- **단순하지만 비효율적인 방법**
  - 삽입정렬, 선택정렬, 버블정렬 등
- **복잡하지만 효율적인 방법**
  - 퀵정렬, 힙정렬, 병합정렬 등 
- **내부 정렬(internal sorting)** 
  - 모든 데이터가 주기억장치에 저장되어있는 상태에서 정렬
- **외부 정렬(external sorting)**
  - 외부기억장치에 대부분의 데이터가 있고 일부만 주기억장치에 저장된 상태에서 정렬 – 병합정렬 기반(k-way merging) (생략)
- **정렬 알고리즘의 안정성(stability)**
  - 동일한 키 값을 갖는 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음

## 선택 정렬 - selection sort

**설명**

**정렬된 왼쪽 리스트와 정렬 안된 오른쪽 리스트 가정**

- 초기에는 왼쪽 리스트는 비어 있 고, 정렬할 숫자들은 모두 오른쪽 리스트에 존재

**오른쪽 리스트에서 최소값 선택하여 오른쪽 리스트의 첫번째 수와 교환**

- 왼쪽 리스트 크기 1 증가
- 오른쪽 리스트 크기 1 감소 
- 오른쪽 리스트가 소진되면 정렬 완료

![image](https://user-images.githubusercontent.com/68107000/99208990-6044c800-2805-11eb-8795-5de25fac313b.png)

**pseudocode**

```c
selection_sort(A, n)
for i←0 to n-2 do
    least ← A[i], A[i+1],..., A[n-1] 중에서 가장 작은 값의 인덱스;
    A[i]와 A[least]의 교환;
    i++;
```

**C 구현**

```c
#define SWAP(x, y, t) ( (t)=(x), (x)=(y), (y)=(t) )
void selection_sort(int list[], int n) {
    int i, j, least, temp;
    for (i=0; i<n-1; i++) {
        least = i;
        for (j=i+1; j<n; j++) // 최소값 탐색
            if(list[j]<list[least]) least = j;
        SWAP(list[i], list[least], temp);
    }
}
```

**선택 정렬 복잡도 분석**

- 비교 횟수
- 이동 횟수
- 전체 시간 복잡도
- 안정성을 만족하지 않음
  - 예) 3 3 1 5

## 삽입 정렬

## 버블 정렬

## 병합 정렬

## 퀵 정렬

## 힙 정렬

