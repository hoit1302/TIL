# 5장 관계 데이터 모델

## 01. 관계 데이터 모델의 개념

**개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델**

하나의 개체에 대한 데이터를 **하나의 릴레이션**에 저장

### 01-1. 관계 데이터 모델의 기본 용어

![image](https://user-images.githubusercontent.com/68107000/111353038-38d50d80-86c8-11eb-89e0-ef661017d437.png)

- **릴레이션(relation)** 
  - 하나의 개체에 관한 **데이터**를 2차원 테이블의 구조로 저장한 것 
  - 파일 관리 시스템 관점에서 하나의 파일(file)에 대응
- **속성(attribute)** 
  - 릴레이션의 열, **애트리뷰트**
  - 파일 관리 시스템 관점에서 **필드(field)**에 대응
- **투플(tuple)**
  - 릴레이션의 행
  - 파일 관리 시스템 관점에서 **레코드(record)**에 대응
- **도메인(domain)**
  - 하나의 속성이 가질 수 있는 모든 (원자) 값의 집합 (다중 값 속성 X)
  - 속성 값을 **입력** 및 수정할 때 **적합성 판단**의 기준이 됨 (입력 제약)
  - 일반적으로 속성의 특성을 고려한 **데이터 타입**으로 정의
  - 내가 직접 정의할 수 있다. ex) grade = {vip, gold, silver, bronze}
- **널(null)**
  - 속성 값을 아직 모르거나 해당되는 값이 없음을 표현
  - DB마다 표현법이 다름
  - 공백, 0과는 다른 의미
- **차수(degree)**
  - 하나의 릴레이션에서 **속성의 전체 개수**
  - 정적인 특징
- **카디널리티(cardicality)**
  - 하나의 릴레이션에서 투플의 전체 개수
  - 동적인 특징

### 01-2. 릴레이션의 구성

![image](https://user-images.githubusercontent.com/68107000/111353574-c7498f00-86c8-11eb-852b-56b0361241b5.png)

- **릴레이션 스키마(relation schema)**
  - 릴레이션의 논리적 구조
  - 릴레이션의 이름과 릴레이션에 포함된 모든 속성 이름으로 정의
  - 예) 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금)
  - 릴레이션 내포(relation intension)라고도 함
  - DD(definite)L로 실행됨.
  - **정적**인 특징이 있음
- **릴레이션 인스턴스(relation instance)** 
  - 어느 한 시점에 릴레이션에 존재하는 투플들의 집합 
  - 릴레이션 외연(relation extension)이라고도 함 
  - DM(manipulate)L로 실행됨.
  - **동적**인 특징이 있음

### 01-3. 데이터베이스의 구성

![image](https://user-images.githubusercontent.com/68107000/111354022-38894200-86c9-11eb-9267-babf84833c74.png)

![image](https://user-images.githubusercontent.com/68107000/111354279-7dad7400-86c9-11eb-9eee-9456429ec66f.png)

- **데이터베이스 스키마(database schema)** 	
  - 데이터베이스의 전체 구조 
  - 데이터베이스를 구성하는 **릴레이션 스키마의 모음**
- **데이터베이스 인스턴스(database instance)** 
  - 데이터베이스를 구성하는 **릴레이션 인스턴스의 모음**

### 01-4. 릴레이션의 특성

✓ 수학의 집합과 아주 비슷하다.

- 투플의 **유일성**: 하나의 릴레이션에는 동일한 투플이 존재할 수 없다. key 속성을 통해 구별한다.
- 투플의 **무순서**: 하나의 릴레이션에서 **투플 사이의 순서**는 무의미하다. 그냥 insert 된 순서로 보일 뿐이다.
- 속성의 **무순서**: 하나의 릴레이션에서 **속성 사이의 순서**는 무의미하다. 속성 값에 접근할 때 속서으이 위치로 접근하지 않고 속성의 이름으로 접근하기 때문이다.
- 속성의 **원자성**: 속성 값으로 원자 값만 사용할 수 있다. 
  - 더 분해할 수 없음 
  - 다중값을 사용할 수 없음.

### 01-5. 키

> 릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합

![image](https://user-images.githubusercontent.com/68107000/111366119-76d92e00-86d6-11eb-8020-8114c65c6f31.png)

- **키의 특성**
  - **유일성(uniqueness)**: 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함
  - **최소성(minimality)**: 꼭 필요한 최소한의 속성들로만 키를 구성
- **키의 종류**
  - **슈퍼키(super key)** 
    - 유일성을 만족하는 속성 또는 속성들의 집합
    - 예) 고객 릴레이션의 슈퍼키 : 고객아이디, (고객아이디, 고객이름), (고객이름,  주소) 등
  - **후보키(candidate key)**
    - 유일성과 최소성을 만족하는 속성 또는 속성들의 집합 
    - 예) 고객 릴레이션의 후보키 : 고객아이디, (고객이름, 주소) 등 
  - **기본키(primary key)**
    - 후보키 중에서 기본적으로 사용하기 위해 선택한 키
    - 예) 고객 릴레이션의 기본키 : 고객아이디 
  - **대체키(alternate key)** 
    - 기본키로 선택되지 못한 후보키
    - 예) 고객 릴레이션의 대체키 : (고객이름, 주소)
  - **외래키(foreign key)**
    - **다른 릴레이션의 기본키(대체키)를 참조**하는 속성 또는 속성들의 집합
    - 릴레이션들 간의 관계를 표현
      - 참조하는 릴레이션 : 외래키를 가진 릴레이션
      - 참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션
    - 외래키 속성과 그것이 참조하는 기본키 속성의 이름은 달라도 되지만 도메인은 같아야 한다.
    - 하나의 릴레이션에는 외래키가 여러 개 존재할 수도 있고 외래키를 기본키로 사용할 수도 있다. 또한 외래키를 포함하여 기본키를 구성할 수도 있다.
    - 같은 릴레이션의 기본키를 참조하는 외래키도 정의할 수 있다. (순환 관계)
    - 외래키 속성은 널 값을 가질 수도 있다.

*정리*

![image](https://user-images.githubusercontent.com/68107000/111366801-58276700-86d7-11eb-8da3-6158d74a2067.png)

## 02. 관계 데이터 모델의 제약

**무결성 제약조건(integrity constraint)**

- 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
- 무결성: 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것

![image](https://user-images.githubusercontent.com/68107000/111367054-a63c6a80-86d7-11eb-8d16-3fdbdbed739c.png)

- **개체 무결성 제약조건(entity integrity constraint)**

  - **기본키**를 구성하는 모든 속성은 **널 값을 가질 수 없**는 규칙
  - DBMS는 기본키 지정을 한 속성에 널 값을 넣으려 하면 에러가 난다.

- **참조 무결성 제약조건(referential integrity constraint)**

  - 외래키는 참조할 수 없는 값을 가질 수 없는 규칙

  - ex) 

    ![image](https://user-images.githubusercontent.com/68107000/111367809-76419700-86d8-11eb-9d89-7f9f8fa6b7aa.png)

    고객 릴레이션에 존재하지 않는 고객이 주문함 ㅡ> DBMS가 참조를 막음

  - **하지만 외래키 속성이 null 값을 가진다고 해서 참조 무결성 제약조건을 위반하는 것은 아니다**. 고개 릴레이션에 존재하지 않는 고객이 주문했다고 판단하기엔 어려움이 있다. 그저 속성 값이 누군지 모를 뿐이다.

