# 10장 회복과 병행 제어

## 1 트랜잭션(transaction)

### 1-1. 트랜잭션이란?

- 하나의 작업을 수행하는데 필요한 데이터베이스 연산의 모음
- 작업 수행에 필요한 sql문들의 모임
  - EX) 특히, 데이터베이스를 변경하는 INSERT, DELETE, UPDATE문의 실행을 관리
- **논리적인 작업의 단위**
- 장애 발생시 복구 작업이나 병행제어 작업을 위한 중요한 단위로 사용됨
- 데이터베이스의 무결성과 일관성을 보장하기 위해

**예시**

`계좌이체 트랜잭션`의 경우 돈이 인출되는 UPDATE 문과 돈이 입근되는 UPDATE 문이 처리 순서는 중요하지 않지만 모두 정상적으로 실행되어야 한다. 

### 1-2 특성 (ACID)

> 원자성, 일관성, 격리성, 지속성

#### **원자성(atomicity)**

- 트랜잭션의 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야하는 all-or-nothing방식을 의미한다.
- 만약 트랜잭션 수행 도중 장애가 발생한다면? 
  - 데이터베이스를 트랜잭션 작업 전 상태로 되돌려야 함 (데이터베이스를 다시 롤백해야함.)

- 원자성의 보장을 위해 장애 발생시 회복 기능이 필요

#### **일관성(consistency)**

트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함을 의미

- '일관성 여부' 는 사용자가 판단하고 정리해야 함
- '일관성이 유지되도록 트랜잭션을 정의하는 것'은 데이터베이스 개발자의 책임

#### **격리성(isolation)**

수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없음을 의미

트랜잭션 실행 과정에서 갱신된 데이터는 트랜잭션 완료 시까지 다른 트랜잭션이 참조할 수 없음을 의미

- 격리성의 보장을 위해서는 여러 트랜잭션이 동시에 수행되더라도 마치 순서대로 하나씩 수행되는 것처럼 정확하고 일관된 결과를 얻을 수 있도록 제어하는 기능이 필요하다.


#### **지속성(durability)**

- 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 **영구적**이어야 함을 의미
- 지속성의 보장을 위해서는 장애 발생 시 회복 기능이 필요


### 1-3 트랜잭션의 특성을 지원하는 DBMS의 기능

원자성(all or nothing) ← 회복 기능
일관성(수행 전 후가) ← 병행 제어 기능
격리성(작업 중 접근 X) **←** 병행 제어 기능
지속성(영구적) ← 회복 기능

### 1-4 트랜잭션의 연산

> commit rollback

**commit 연산**

- 트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산
- commit 연산이 실행되면 **트랜잭션의 수행 결과가 데이터베이스에 반영** 되고 일관된 상태를 지속적으로 유지하게 됨

**rollback 연산**

- 트랜잭션의 수행이 실패했음을 선언하는 연산
- rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 **데이터베이스가 트랜잭션 수행 전의 일관된 상태로 되돌아감**

### 1-5 트랜잭션의 상태

![image](https://user-images.githubusercontent.com/68107000/122659776-2b8f5980-d1b6-11eb-8a2e-ffcf0ff527e1.png)

**A. 활동(active) 상태**

- 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태

**B. 부분 완료(partially committed) 상태**

-  트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태

**C. 완료(committed) 상태**

- 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
- 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하고, 데이터베이스가 새로운 일관된 상태가 되면서 트랜잭션이 종료된다.

**D. 실패 상태**

- 장애가 발생하여 트랜잭션의 수행이 중단된 상태

**E. 철회 상태**

- 트랜잭션의 수행 실패로 rollback 연산을 실행한 상태
- 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 트랜잭션이 수행되기 전의 데이터베이스 상태로 되돌리면서 트랜잭션이 종료됨
- 철회 상태로 종료된 트랜잭션은 상황에 따라 다시 수행되거나 폐기됨

## 2 장애와 회복

### 2-1. 장애란?

**장애**: 시스템이 제대로 동작하지 않는 상태;

### 2-2. 장애의 유형

**트랜잭션 장애**
의미: 트랜잭션 수행 중 오류가 발생하여 정상적으로 수행이 불가능함
원인: 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 시스템 자원의 과다 사용 요구, 처리 대상 데이터의 부재 등

**시스템 장애**
의미: 하드웨어의 결함으로 정상적으로 수행을 계속할 수 없는 상태
원인: 하드웨어 이상으로 메인 메모리에 저장된 정보가 손실되거나 교착상태가 발생한 경우 등

**미디어 장애**
의미: 디스크 장치의 결함으로 디스크에 저장된 데이터베이스의 일부 혹은 전체가 손상된 상태
원인: 디스크 헤드의 손상이나 고장 등

### 2-3. 데이터베이스 저장 장치의 종류

**휘발성volatile 저장 장치(소멸성)**

- 장애가 발생하면 저장된 데이터가 손실됨
- ex) 메인 메모리등

**비휘발성nonvolatile 저장 장치(비소멸성)**

- 장애가 발생해도 데이터 손실이 없음
- 디스크 헤더 손상 같은 저장 장치 자체에 이상이 발생하면 데이터가 손실 될 수 있음
- ex) 디스크, 자기 테이프 CD/DVD 등

**안정stable 저장 장치**

- 비휘발성 저장 장치를 이용하여 데이터 **복사본 여러개**를 만드는 방법으로 어떤 장애가 발생해도 데이터가 손실 되지 않고 영구적으로 저장 가능

### 2-4. 데이터 이동 연산

![image](https://user-images.githubusercontent.com/68107000/122661729-63070180-d1c8-11eb-8cd9-8287504f7cfc.png)

- **디스크**와 **메인 메모리** 간의 데이터 이동 연산 - **input / output**
  - 트랜잭션이 데이터베이스의 데이터를 처리하기 위해서는 데이터를 디스크에서 메인 메모리로 가져와 처리한 다음 그 결과를 디스크로 보내는 작업이 필요함
  - 블록(block) 단위로 수행됨
    - disk block: 디스크에 있는 블록;
    - buffer block: 메인 메모리에 있는 블록;
- **메인 메모리**와 **프로그램 변수** 간의 데이터 이동 연산 - **read / write**
  - 응용 프로그램에서 트랜잭션의 수행을 지시하면 메인 메모리 버퍼 블록에 있는 데이터를 프로그램의 변수로 가져오고, 데이터 처리 결과를 저장한 변수 값을 메인 메모리 버퍼 블록으로 옮기는 작업이 필요함

**예시**

![image](https://user-images.githubusercontent.com/68107000/122661754-cdb83d00-d1c8-11eb-8625-3eaaa3df99f7.png)

### 2-5. 회복이란?

- 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 모순이 없고 일관된 상태로 복구시키는 것
- 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능 
- 회복 관리자(recovery manager)가 담당
  - 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스 복구 기능을 제공

### 2-6. 회복을 위한 연산과 파일

**데이터 회복의 핵심 원리는 데이터 중복**

- 데이터를 별도의 장소에 복사해두고, 문제 발생 시 복사본을 이용하여 원래의 상태로 복원하는 것

**데이터베이스 회복을 위해 복사본을 만드는 두 가지 방법**

- **덤프**: 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법;

- **로그**: 데이터베이스에서 **변경 연산이 실행 될때마다** 데이터 변경 이전 값과 이후의 값을 별도의 파일에 기록하는 방법;

  - **로그 파일**: 데이터베이스에 대한 변경 연산과 관련하여 데이터를 변경하기 이전과 이후의 값을 기록한 파일

  - **로그 레코드**: 로그 파일은 레코드 단위로 트랜잭션 수행과 함께 기록

  - 로그 레코드의 4가지 종류

  - 

    ![image](https://user-images.githubusercontent.com/68107000/122661884-c9405400-d1c9-11eb-9b94-314b5a574ecf.png)

**가장 기본적인 두 가지 회복 방법**

- **redo**: 로그에 기록된 변경 연산 후의 값을 이용하여 변경 연산을 재실행한다.
- **undo**: 로그에 기록된 변경 연산 이전의 값을 이용하여 변경 연산을 취소하는 방법으로 데이터베이스를 복구한다.

**로그 기록의 예**:  계좌 잔액이 10,000원인 X가 계좌 잔액이 0원인 Y에게 5,000원 이체

![image](https://user-images.githubusercontent.com/68107000/122661960-73b87700-d1ca-11eb-8fd7-e273ec758349.png)

### 2-7. 회복 기법

![image](https://user-images.githubusercontent.com/68107000/122661853-96965b80-d1c9-11eb-88e5-b15c564b350a.png)

#### 즉시 갱신 회복 기법

- 트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영
- 장애 발생에 대비하기 위해 데이터변경에 대한 내용을 로그파일에 기록

  - 데이터 변경 연산이 실행되면, 로그 파일에 로그 레코드를 먼저 기록한 다음 데이터베이스에 변경 연산을 반영
- 장애 발생 시점에 따라 redo나 undo 연산을 실행하여 데이터베이스를 복구

**연산 적용 방법**

- 트랜잭션 완료되기 전일 경우 (로그 파일에 \<Ti, start\> 레코드는 존재하지만 \<Ti, commit> 레코드는 존재하지 않는 경우): 해당 트랜잭션에 undo 연산 시행
- 완료된 이후면 (로그 파일에 \<Ti, start\>과 \<Ti, commit> 레코드가 모두 존재하는 경우): 해당 트랜잭션에 redo 연산 시행

#### 지연 갱신 회복 기법

- 트랜잭션이 수행되는 도중 데이터 변경 연산의 결과를 (즉시 반영하지 않고) 로그에만 기록해두고, 부분 완료된 후에 로그에 기록된 내용을 이용하여 **데이터베이스에 한번에 반영**
- 트랜잭션 수행 중에 장애가 발생할 경우 로그에 기록된 내용을 버리기만 하면 원래 상태를 그대로 유지하게 됨

**연산 적용 방법**

- 트랜잭션 수행 중에 장애가 발생할 경우 로그에 기록된 내용을 버리기만 하면 데이터베이스가 원래 상태를 그대로 유지하게 됨
  - 지역 갱신 회복 기법에서는 undo 연산은 필요없음
  - 로그 레코드에 변경 이전 값을 기록할 필요가 없으므로 \<T1, X, new_value\> 로 레코드 형식이 변함
- 트랜잭션 완료되기 전일 경우 (로그 파일에 \<Ti, start\> 레코드는 존재하지만 \<Ti, commit> 레코드는 존재하지 않는 경우): 로그 무시하고 버림
- 완료된 이후면 (로그 파일에 \<Ti, start\>과 \<Ti, commit> 레코드가 모두 존재하는 경우): 해당 트랜잭션에 redo 연산 시행

#### 검사 시점 회복 기법

- **로그 기록을 이용**하되, 일정 시간 간격으로 검사 시점(checkpoint)을 만듦
- 장애가 발생 시 가장 최근 검사 시점 이전의 트랜잭션에는 회복 작업을 수행하지 않고, \<checkpoint L> 로그 레코드 이후의 기록에 대해서만 회복 작업(즉시 갱신 또는 지연 갱신 회복 기법)을 이용해 수행
- 로그 전체를 대상으로 회복 기법을 적용할 때 발생할 수 있는 비효율성의 문제를 해결
  - 검사 시점으로 작업 범위가 정해지므로 불필요한 회복 작업이 없어 시간이 단축됨

#### 미디어 회복 기법

- 디스크에 발생할 수 있는 장애에 대비한 회복 기법
- 덤프(복사본) 이용
  - 전체 데이터베이스의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사
- 디스크에 장애가 발생하면?
  1. 덤프를 이용하여 장애 발생 이전의 데이터베이스 상태로 복구
  2. 로그의 내용을 토대로 redo 연산 실행

## 3 병행 제어

### 3-1. 병행 수행과 병행 제어란?

#### 병행 수행

- 여러 사용자가 데이터베이스를 **동시에 공유**할 수 있도록 **여러 개의 트랜잭션을 동시에 수행**하는 것을 의미
- 여러 트랜잭션들이 **차례로 번갈아** 수행되는 **interleaving** 방식으로 진행된다.

#### 병행 제어

병행 수행 시 같은 데이터에 접근하여 연산을 실행해도 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것을 의미

### 3-2. 병행 수행 시 발생할 수 있는 문제점

- 병행 수행을 특별한 제어 없이 진행할 경우 발생된다.

#### 갱신 분실

- 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것
- 여러 트랜잭션이 동시에 수행되더라도 갱신 문제가 발생하지 않고 마치 트랜잭션이 순차적으로 수행한 것과 같은 결과값을 얻을 수 있어야 함.

#### 모순성(inconsistency)

- 하나의 트랜잭션이 여러 개 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행해서 모순된 결과가 발생하는 것
- 여러 트랜잭션이 동시에 수행되어도 모순성이 발생되지 않고, 순차적으로 수행과 같은 값을 얻어야 함

#### 연쇄 복귀(cascading rollback)

- 트랜잭션이 완료되기 전에 장애가 발생하여 rollback연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또 다른 트랜잭션에도 rollback연산을 연쇄적으로 실행해야 한다는 것
- 여러 트랜잭션이 동시에 수행되더라도 연쇄 복귀가 발생하지 않고 순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 함
- ![image](https://user-images.githubusercontent.com/68107000/122662096-5d5eeb00-d1cb-11eb-81cd-38bf56c35ff5.png)

### 3-3. 트랜잭션 스케쥴

- 트랜잭션들의 연산을 실행하는 순서

#### 직렬serial 스케쥴

- 의미
  - 인터리빙 방식을 이용하지 않고 각 트랜잭션별로 연산들을 순차적으로 실행시키는 것
- 특징
  -  다른 트랜잭션의 방해를 받지 않고 **독립적으로 수행**되므로 **항상 모순이 없는 정확한 결과**를 얻게 됨.
  - 다양한 직렬 스케줄이 만들어질 수 있고, 직렬 스케줄마다 데이터베이스에 반영되는 최종 결과가 다를 수 있지만 직렬 스케줄의 결과는 모두 정확함
  - **인터리빙 방식을 사용하지 않기 때문에 병행수행이라고는 할 수 없음**

#### 비직렬nonserial 스케쥴

- 의미
  - 인터리빙 방식을 사용하여 트랜잭션을 병행해서 수행시키는 것
- 특징
  - 하나의 트랜잭션 완료 전에 다른 트랜잭션 수행이 가능하다.
  - 실행 순서에 따라 다양한 비직렬 스케쥴이 만들어지고, 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생하여 **결과의 정확성을 보장할 수 없음**

다양한 비직렬 스케줄 중 **문제가 발생하는 비직렬 스케줄의 예시**

![image](https://user-images.githubusercontent.com/68107000/122662226-39e87000-d1cc-11eb-8a61-dbf2b0640201.png)

#### 직렬 가능serializable 스케쥴

- 의미
  - 비직렬 스케줄 중에서 수행 결과가 동일한 직렬 스케줄이 있는 것
- 특징
  - 인터리빙 방식으로 병행 수행하면서도 직렬 스케쥴에 따라 수행한 것과 같이 정확한 결과를 얻을 수 있음
  - 직렬 가능 스케줄인지 판단하는 것은 간단한 작업이 아니므로 **직렬 가능성을 보장하는 병행 제어 기법을 사용하는 것이 일반적임**

### 3-4 병행 제어 기법

**의미**

- 병행 수행하면서도 직렬 가능성을 보장하기 위한 기법

**방법**

- 모든 트랜잭션이 준수하면 직렬 가능성이 보장되는 규약을 정의하고, 트랜 잭션들이 이 규약을 따르도록 함

**대표적인 병행 제어 기법** 

- 로킹 기법

### 3-5 로킹 기법 (대표적인 병행 제어 기법)

**기본 원리**

- 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 끝낼 때까지는 다른 트랜잭 션이 그 데이터에 접근하지 못하도록 상호 배제(mutual exclusion)함

**방법**

- 병행 수행되는 트랜잭션들이 같은 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산을 이용해 제어
  - **lock**: 트랜잭션이 데이터에 대한 독점권을 요청하는 연산 
  - **unlock**: 트랜잭션이 데이터에 대한 독점권을 반환하는 연산

#### 기본 로킹 규약
1. 트랜잭션은 데이터에 접근하기 위해 먼저 lock 연산을 실행해 독점권을 획득함
   - read 또는 write 연산을 실행하기 전 lock 연산을 실행
2. 다른 트랜잭션에 의해 이미 lock 연산이 실행된 데이터에는 다시 lock 연산을 실행할 수 없음
3. 독점권을 획득한 데이터에 대한 모든 연산의 수행이 끝나면 트랜잭션은 unlock 연산을 실행해서 독점권을 반납해야 함

**로킹 단위**

- lock연산을 실행하는 대상 데이터의 크기
- 전체 데이터베이스부터 릴레이션, 투플, 속성까지도 가능함
- 로킹 단위가 커질 수록 병행성은 낮아지지만 제어가 쉽고, 로킹 단위가 작아질수록 제어가 어렵지만 병행성은 높아짐

**기본 로킹 규약의 효율성을 높이기 위한 방법**

- 트랜잭션들이 같은 데이터에 동시에 read 연산을 실행하는 것을 허용함
- lock 연산을 두 가지 종류로 구분하여 사용함
  1. **shared lock**
     - 트랜잭션이 데이터에 공용 lock 연산을 실행하면 (같은 트랜잭션이) 해당 데이터에 read 연산을 실행할 수는 있지만 write 연산은 실행할 수 없음
     - 다른 트랜잭션도 공용 lock 연산을 동시에 실행할 수 있음 (데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음)
  2. **exclusive lock**
     - 트랜잭션이 데이터에 전용 lock 연산을 실행하면 (같은 트랜잭션이) 해당 데이터에 read 연산과 write 연산을 모두 실행할 수 있다. 
     - 다른 트랜잭션은 어떠한 lock연산도 실행이 불가능하다. (전용 lock 연산을 실행한 트랜잭션은 해당 데이터에 대한 독점권을 가짐)

**문제점**

하지만 앞선 기본 로킹 규약만으로는 lock과 unlock연산의 수행 시점에 관한 모순성의 문제가 발생한다.

![image](https://user-images.githubusercontent.com/68107000/122659447-54621f80-d1b3-11eb-88d3-9ac1a5712a08.png)

트랜잭션 T1이 데이터 X에 너무 빨리 unlock 연산을 실행하여 트랜잭션 T2가 일관성 없는 데이터에 접근했기 때문에 문제점이 발생하는 것을 확인할 수 있다.

2단계  로킹 규약을 통해 해결할 수 있다.

#### 2단계 로킹 규약

**의미**

- 기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 lock과 unlock 연산의 수행 시점에 대한 새로운 규약을 추가한 것

**방법**

- 트랜잭션이 lock과 unlock 연산을 확장 단계와 축소 단계로 나누어 실행
  1. 트랜잭션이 처음 수행되면 **확장 단계**로 들어가 lock 연산만 실행 가능
  2. unlock 연산을 실행하면 **축소 단계**로 들어가 unlock 연산만 실행 가능
  3. 트랜잭션은 첫 번째 unlock 연산 실행 전에 필요한 모든 lock 연산을 실행해야 함

확장 단계: 트랜잭션이 lock연산만 실행하고, unlock연산은 실행 할 수 없는 단계
축소 단계: 트랜잭션이 unlock연산만 실행하고 lock은 실행 불가능

- 다만 **교착상태(deadlock)**이 발생할 수 있다. 
  - 교착 상태란: 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 트랜잭션의 수행을 중단하고 있는 상태;
  - 이는 처음부터 발생하지 않도록 예방하거나, 빨리 탐지하여 필요한 조치를 취해야함.

**2단계 로킹 규약을 준수하여 직렬 가능성이 보장된 스케줄 예**

![image](https://user-images.githubusercontent.com/68107000/122659260-35fb2480-d1b1-11eb-90d3-c009e1becbf7.png)

